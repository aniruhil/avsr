---
title: "R Script for Chapter 2"
author: "ani"
date: "January 15, 2015"
output:
  html_document:
    fig_width: 8
    highlight: haddock
    keep_md: yes
---

### Accessing Whitlock and Schluter's Data
There are three ways to access the data used in the textbook.

* Using the R Code provided by the authors. This technique imports the data from the authors' website. Although there are better ways to generate plots and tables this path may be the best for you for now. It ensures that you have the most 
* Downloading the data from the authors' website to a local directory and opening it from there. Useful if you don't have internet access 24/7, and if the data are to be used for an assignment. 
* Using the "abd" library that was created specifically to use all data used by Whitlock and Schluter in the first edition of the text. The data may not have changed much so the library could still be useful. However, there are no guarantees if you go this route.  


If you plan to go the "abd" route then you will need to install the package via the <code>install.packages("abd")</code> command.

**Note:** RStudio may not compile the notebook if you have any <code>install.packages("")</code> command(s) in your Script. If this happens you should first install the package and then use <code>#</code> to comment out the offending install command(s) in your Script **and then compile the notebook**. See below for an example.

```{r}
# install.packages("abd")
```

Once installed packages reside on your computer until they get corrupted or something else breaks. Whenever you want to use a package you have to call it via <code>library(abd)</code>

You can use the <code>help</code> function in the bottom-right window of RStudio to search for the details of a data-set, a package, a command, etc. 

**Note:** A word of caution. Some times the data will be in a raw format and hence easy to work with. At other times they may be given to us in some form of a frequency table or some other tabular format. When this happens and you need to use the data for some plot or calculation I will either provide you with the code needed to flip the data into a usable format.  


### Working with Categorical Data
Recall that categorical data merely capture a set of attributes or traits of the sampled units. Thus, for example, the various causes of death of teens are all categorical. So also the tigerData. If I have a single categorical variable then the best ways to map its distribution is either via (a) a Frequency Table, or with (b) a Bar Chart.  

<code>tigerData:</code> The following data relate to the activities of 88 people at the time they were killed by tigers near Chitwan National Park, Nepal, from 1979 to 2006.
```{r}
tigerData <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02e2aDeathsFromTigers.csv"))
head(tigerData)
table(tigerData$activity)
tab.T <- sort(table(tigerData$activity), decreasing = TRUE)
tab.T
data.frame(Frequency = tab.T)
data.frame(Frequency = addmargins(tab.T))
```

The <code>table(tigerData$activity)</code> command constructs a frequency table that is arranged in ascending order of the activity labels. This is rarely a useful ordering of the data. Instead we usually want the table sorted in descending or ascending order of the frequencies. This is achieved via the 
<code>sort(table(tigerData$activity), decreasing = TRUE)</code> and <code>sort(table(tigerData$activity), decreasing = FALSE)</code> commands. I have also saved the table with a name <code>tab.T</code>. I can improve how it is displayed in the console via the <code>data.frame(Frequency = tab.T)</code> command. Finally, <code>addmargins</code> calculates and appends the sum of the frequencies. 

If I wanted to display Relative Frequencies I would have run:
```{r}
tab.T2 <- prop.table(tab.T)
tab.T2
data.frame(Relative.Frequency = tab.T2)
data.frame(Relative.Frequency = addmargins(tab.T2))
```


What about a bar chart (aka bar plot)? A simple one can be drawn as follows
```{r}
barplot(tab.T, ylab = "Frequency", ylim=c(0,50), cex.names = 0.5, las = 2, main="Activities Linked to Fatal Tiger Attacks")
```

**Note:** <code>cex.names</code> is basically setting the font-size for the labels. Change the value from 0.65 to something else and see what it does. Change <code>las</code> to 1 and see what that does. In general, there are many more tweaks available for plots. To see these options, search for <code>bar-plot</code> in help. 

There are better plots that can be created, and <code>ggplot2</code> is by far the best option currently available. Install the ggplot2 library. Then invoke it via the <code>library(ggplot2)</code> command. Then create a bar plot as follows:
```{r}
library(ggplot2)
ggplot(tigerData, aes(x=activity)) + geom_bar() 
```

You can learn more about the various plot options and different graphics that can be constructed via ggplot2. To see what you can do with ggplot2 check out [this cookbook](http://docs.ggplot2.org/current/)


#### Manipulating Data Provided as a Frequency Table
See these data; they are given to us in a different format:
```{r}
library(abd)
data(TeenDeaths) 
names(TeenDeaths) 
colnames <- c("Cause", "Freq") 
names(TeenDeaths) <- colnames 
```

Once this code has run you'll see <code>TeenDeaths</code> in the upper-right window of RStudio. Open it by clicking on TeenDeaths; a familiar looking spreadsheet will result. Notice that this is a frequency table itself. But I want to expand this into a proper data-set so that I can then work with the data as needed. The code below will do this for us.
```{r}
expand.dft <- function(x, na.strings = "NA", as.is = FALSE, dec = ".")
{
  # Take each row in the source data frame table and replicate it
  # using the Freq value
DF <- sapply(1:nrow(x), function(i) x[rep(i, each = x$Freq[i]), ], simplify = FALSE)
  # Take the above list and rbind it to create a single DF
  # Also subset the result to eliminate the Freq column
DF <- subset(do.call("rbind", DF), select = -Freq)
  # Now apply type.convert to the character coerced factor columns
  # to facilitate data type selection for each column
DF <- as.data.frame(lapply(DF, function(x) type.convert(as.character(x),  na.strings = na.strings, as.is = as.is, dec = dec)))
  # Return data frame
DF
}
```

Now we can run the function on TeenDeaths and save the resulting file under a different name ("teen"):
```{r}
teen <- expand.dft(TeenDeaths)
```

Open <code>teen</code> and see how it looks similar to the tigerDeaths data. We can now calculate frequency tables, bar-plots, etc with ease. 

#### Another Example 
```{r}
data(EndangeredSpecies)
names(EndangeredSpecies)
colnames <- c("Taxon", "Freq")
names(EndangeredSpecies) <- colnames
species <- expand.dft(EndangeredSpecies)
table.1 <- table(species)  
table.1

sort(table.1) 
addmargins(sort(table.1, decreasing=TRUE)) 
ggplot(species, aes(x=Taxon)) + geom_bar() 
```

**Note:** The preceding bar plot doesn't need the labels to be abbreviated because they are small enough. Else we would have had to use the <code>labels=abbreviate</code> command.

Work through the authors' R Code for Chapter 02 to practice constructing bar-plots for different data-sets. 


### Working with Numerical Data
Now lets switch to a numerical variable. Two renditions are valuable here ... (1) a **grouped frequency table** and (2) a **histogram**. We'll start with the grouped frequency table

Numerical variables will, by definition, assume a wide range of values. These values will often be too many to be able to construct a meaningful plot with the raw data. Let us see what this means with the following data:
```{r}
data(iris) # See http://en.wikipedia.org/wiki/Iris_flower_data_set for details
names(iris)
table(iris$Sepal.Length)
```

Notice how useless is the resulting table. This is so because each value of Sepal Length is being used to construct the Frequency Table. Nobody is really ever interested in this level of granularity. Instead, it would make sense to construct groups of Sepal Lengths and see how many data points fall within each group. How many groups we should create will be a matter of trial-and-error. 
```{r}
range(iris$Sepal.Length) # Find minimum and maximum values
breaks <- seq(4.0, 8.0, by=0.5) # Create splitting points for the groups
breaks # See the breaks
SL.cut <- cut(iris$Sepal.Length, breaks, right=FALSE) # Create the groups
SL.cut # See what group each observation falls in
SL.freq <- table(SL.cut)
SL.freq # See the Grouped Frequency Table
```

**Note:** The option <code>right=FALSE</code> says construct the groups to be closed on the left and open on the right. Open intervals do not include the endpoints; only values between the endpoints will be included in the group. Closed intervals will include values that equal the endpoints and values that fall between the endpoints. Thus, in this example, a value of 4 will be bundled into the $[4,4.5)$ group but a value of 4.5 will be reserved for the $[4.5,5)$ group, and so on. 

Now lets construct the histogram for these grouped Sepal Lengths. 

```{r}
hist(iris$Sepal.Length, ylab="Frequency", xlab="Sepal Length", ylim=c(0,35), breaks=breaks, right=FALSE, col="gray", main="Grouped Histogram of Sepal Length")
```

We've ignored the fact that there are three species here, and they may have different sepal lengths. We can fix that as follows:
```{r}
histogram(~ Sepal.Length | Species, data=iris, ylab="Frequency", xlab="Sepal Length", ylim=c(0,60), freq=TRUE, breaks=breaks, right=FALSE,  main="", col="gray", layout = c(1,3))
```

This is essentially how we could construct histograms for some numerical variable that has been measured for different groups. The example below does this for the Hemoglobin data. 
```{r}
hemoglobinData <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02e3cHumanHemoglobinElevation.csv"))
histogram(~ hemoglobin | population, data = hemoglobinData,
  layout = c(1,4), col = "firebrick", breaks = seq(10,26,by=1))
```

What follows is a demonstration of how differing intervals (how wide each group or bin is) changes the shape of the histogram. The data refer to the body mass of 228 female sockeye salmon sampled from Pick Creek in Alaska. The same data are plotted for three different interval widths: 0.1 kg, 0.3 kg, and 0.5 kg. We will first read the data into R, check the first 6 rows of the data-set, and then construct the three histograms, each with its own interval width.
```{r}
salmonSizeData <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02f2_5SalmonBodySize.csv"))
head(salmonSizeData)
hist(salmonSizeData$massKg, right = FALSE, breaks = seq(1, 4, by=0.1), col = "gray")
hist(salmonSizeData$massKg, right = FALSE, breaks = seq(1, 4, by=0.3), col = "gray")
hist(salmonSizeData$massKg, right = FALSE, breaks = seq(1, 4, by=0.5), col = "gray")
```

Again, run through the authors' R Code for Chapter 02 for additional practice. 


### What if I have two variables to work with?
(a) When both variables are categorical

If both variables are categorical then we can use contingency tables to tabulate the data and see what associations show up. We can also use bar-charts and mosaic plots to graph the data. Let us start with the the contingency table. We will use the avian malaria data-set, and start by reading in the data.

```{r}
birdMalariaData <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02e3aBirdMalaria.csv"))
head(birdMalariaData)
```

You will see three variables but the bird number is basically an ID variable that would allow us to go back t our field notes and see what bird was numbered 1, and so on. As such the key variables are the treatment (i.e., whether the bird was in the Control group or in the Egg Removal group), and the response (i.e., whether the test was positive or negative for avian malaria).

The commands below will construct the needed contingency table:
```{r}
tab.A <- table(birdMalariaData$response, birdMalariaData$treatment)
tab.A
addmargins(tab.A)
tab.B1 <- prop.table(tab.A, 1)
tab.B1
tab.B2 <- prop.table(tab.A, 2)
tab.B2
```

**Note:** <code>prop.table(tab.A, 1)</code> is basically calculating the relative frequencies for each row. Running <code>prop.table(tab.A, 2)</code> is basically calculating the relative frequencies for each column. Looking at <code>tab.B1</code> shows us quite clearly that about 68% of the Egg removal group got malaria, versus only about 32% of the Control group; presumably reproduction does weaken the immune system.

Now let us draw a bar-plot for both variables.
```{r}
barplot(as.matrix(tab.A), beside = TRUE, ylim=c(0,30))
```

The mosaic plot follows:
```{r}
mosaicplot( t(tab.A), sub = "Treatment", ylab = "Relative Frequency", cex.axis = 0.8, main = "Mosaic Plot of Avian Malaria Data", col=c("black", "gray"))
```

(b) When both variables are numerical

There is no logical way to construct a frequency table for these data. Yes, we could group each of the numerical variables and then construct something like the contingency table but that would be risky; grouping both might misrepresent the data. Instead we will focus strictly on graphical renditions of any possible relationship between both variables. This is done via the scatter-plot.
```{r}
guppyFatherSonData <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02e3bGuppyFatherSonAttractiveness.csv"))
head(guppyFatherSonData)
plot(sonAttractiveness ~ fatherOrnamentation, data = guppyFatherSonData)
```

Now I'll pretty it up a bit:
```{r}
plot(sonAttractiveness ~ fatherOrnamentation, data = guppyFatherSonData, xlab="Father's Ornamentation", ylab="Son's Attractiveness", col="black", ylim=c(-1.5, 1.5), xlim=c(0, 1.3))
```

What if I have a numerical variable measured for two or more groups? One example might be the hemoglobin concentration data. The best way to show differences between the groups would be to stack the histograms one above the other (see below). 
```{r}
hemoglobinData <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02e3cHumanHemoglobinElevation.csv"))
head(hemoglobinData)
library(lattice)
histogram(~ hemoglobin | population, data = hemoglobinData,
  layout = c(1,4), col = "gray", breaks = seq(10, 26, by=1))
```

**Note:** The <code>layout = c(1,4)</code> option says stack them into1 column and 4 rows. Because this is a numerical variable we are constructing bins of width = 1. This is ebing done via the <code>breaks = seq(10, 20, by=1)</code> command. The <code> | </code> option says construct the histogram of hemoglobin for each group listed in the population variable. Be careful; if you get an error message that says the lattice library is not found be sure to install it first. 


### A Numerical Variable Measured Over Time (aka a Time Series)
The Measles data -- showing confirmed cases of measles in England and Wales from 1995 to 2011, measured every quarter (i.e., at three month intervals of January-March, April-June, July-September, and October-December) -- is an excellent example. So is the Lynx data-set.
```{r}
measlesData <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02e4aMeaslesOutbreaks.csv"))
head(measlesData)
plot(confirmedCases ~ yearByQuarter, data = measlesData, type="b", xlab="Year", ylab="Confirmed Number of Cases", main="Measles Outbreak by Year (1995.Q1 - 2010.Q4)")
```

**Note:** Here the <code>~</code> symbol is being used to say plot confirmedCases against yearByQuarter. The <code>type="b"</code> says construct a dot for each time point and then link successive dots with a line. If we switched <code>type="b"</code> with <code>type="l"</code> we would get just a straight line connecting successive points. Try it for yourself. 



### Strip Charts
Strip Charts are useful at times, particularly when there is a need to show all individual values in the data-set. Below we construct a strip chart for data on serotonin levels in the central nervous system of desert locusts that were experimentally crowded for 0 (the control group), 1, and 2 hours. We'll begin as usual; reading in the data.
```{r}
locustData <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02f1_2locustSerotonin.csv"))
head(locustData)
stripchart(serotoninLevel ~ treatmentTime, data = locustData, method = "jitter", vertical = TRUE, ylim=c(0,25), ylab="Seratonin Level", xlab="Crowded for 0, 1, 2 hrs")
```

See the authors' R Code for Chapter 02 for more tweaks of the strip chart. Frankly, in my experience most folks are more familiar with histograms than they are with stripcharts. Plus the need to nudge the data points a little bit (called "jittering" in technical parlance) distorts the picture a bit and one should avoid distortions as much as is possible. However, if you see strip charts used a lot in your field or subfield then I would learn how to construct them. 


**Note:** I have not covered pie-charts; avoid them at all cost. Box-plots are very useful for displaying data but I will cover these when we get into Chapter 3 and talk about *order statistics*.  

## Some Examples from Practice Problems in Chapter 02
#### Problem # 6
We start by loading up the endangered species data. 
```{r}
EndangeredSpecies <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02q06EndangeredSpecies.csv"))
```

Now I want to address sub-question (a):

```{r}
colnames(EndangeredSpecies) <- c("Taxon", "Freq")
species <- expand.dft(EndangeredSpecies)
tab.A <- table(species)
tab.A
tab.B <- sort(tab.A, decreasing=FALSE)
tab.B
tab.C <- data.frame(Frequency = tab.B)
tab.C
```

In brief, I have sorted the frequency table in increasing order of the Number of Species. That is, the more engandered species are listed first. This makes intuitive sense since most readers will, when primed by the word "engandered", want to know which species are the most endangered so we might as well present these species first.

(b) I have constructed a frequency table

(c) The best graph would be a bar-plot:
```{r}
barplot(tab.B, ylab="Frequency", xlab="Taxon", ylim=c(0, 800), cex.names=0.8)
```

Given that we are dealing with categorical data the bar-plot is the obvious graphic of choice.

(d) The baseline should be $0$ since any other value would misrepresent the minimum value possible for any taxon, and also distort the plot. 

(e) The relative frequency is shown below:
```{r}
tab.D <- prop.table(tab.B)
tab.E <- data.frame(Rel.Frequency = tab.D)
tab.E
```


#### Problem #17
Read in the data.
```{r}
anemone <- read.csv(url("http://whitlockschluter.zoology.ubc.ca/wp-content/data/chapter02/chap02q17AnemonePersonality.csv"))
anemone
```

(a) The best graph would be a scatter-plot:
```{r}
plot(startleResponse2 ~ startleResponse1, data=anemone, ylim=c(0,1000), xlab="Startle Response 1", ylab="Startle Response 2", pch=16)
```

(b) The scatter-plot shows a positive association between startle response times of sea anemones.


#### Problem #18
(a) The frequency distribution is drawn below:
```{r}
response1 <- anemone$startleResponse1
response1
hist(response1, xlab="Response 1", col="gray", main="Histogram of Response 1")
```

(b) The histogram shows the distribution of Response 1 times to be positively skewed (i.e., skewed right).

